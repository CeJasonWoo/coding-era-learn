// 参考
// 矩阵 快速幂 http://www.cnblogs.com/yan-boy/archive/2012/11/29/2795294.html
// 快速幂代码 http://www.cnblogs.com/ahjesus/p/3261320.html


// a的n次幂
// 常规写法 O(n)
function pow(a, n) {
    var res = 1;
    while (n >= 1) {
        res = res * a;
        n -= 1;
    }
    return res;
}
console.log('pow(a, n) 2^4', pow(2, 12));



// 快速幂
// 传统计算方式如果幂次是100就要循环100遍求值，快速幂计算只需要循环7次即可  

// 我get到的算法思想：
// ======================================================================================================
// 1充分利用现有计算结果
// 既然要减少重复计算，那么就要充分利用现有的计算结果

// ======================================================================================================
// 1.1化连续为离散
// 离散化，就能充分利用现有的计算结果
// 比如：A*A*A*A*A*A  =>  (A*A)*(A*A)*(A*A)
// 这样变的好处是，你只需要计算一次A*A，然后将结果(A*A)连乘自己两次就能得到A^6，即(A*A)^3=A^6。
// 算一下发现这次一共乘了3次，少于原来的5次。

//递归
// 算法思路：
// 1. 如果是奇数幂，x * p(x,n-1)
// 2.如果是偶数幂，p(x , n/2) * p (x, n/2)
// 3. 如果n=0 ，返回1
// 时间复杂度  ： O(logN)

// 我的理解：
// 2^12 = 2^6*2^6 
// 2^6 = 2^3*2^3 
// 2^3 = 2^2*2 
// 2^2 = 2*2
// 通过归并，离散化，达到充分利用现有的计算结果的目的
// 这里让我想到了动态规划，或许究其根本还是那句话：化连续为离散
// TODO 动态规划，递推，归并

function quickPow1(x, n) {
    console.log('--quickPow1', x, n);
    if (n == 0) {
        return 1;
    }
    if (n % 2 == 1) {
        return quickPow1(x, n - 1) * x;
    }
    var r = quickPow1(x, n / 2);
    return r * r;
}
console.log('quickPow1', quickPow1(2, 12));



// ======================================================================================================
// 1.2二进制对算法优化很重要
// 使用二进制也是离散化的一种重要手段
// 很多时候我们并不是为了解决一个问题而使用二进制，更多是时候是为了优化而使用它。

// 我的理解：
// 上面的算法，计算2^12时，先从最大的12着手逐步拆分成2*2，这就要使用到了递归。
// 可不可以直接从2*2开始算起呢？这样就不需要递归了,于是下面用到了二进制算法思想，这真的很精妙。

// 解析：
// 求x的y次方 x^y可以做如下分解
// 把y转换为2进制，设第m位的值为i，计算第m位的权为x^(2^(m-1)*i) 
// 解析x^12：
// 12 的二进制是 1100,根据公式x^(2^(m-1)*i)则有
// 12 = 2^(4-1)*1 + 2^(3-1)*1 + 2^(2-1)*0 + 2^(1-1)*0
// 12 = 2^(3)*1 + 2^(2)*1 + 2^(1)*0 + 2^(0)*0
// 12 = 2^3 + 2^2  （到了这一步分析出了一个很重要的问题，对于1100，实际上我们只需要计算1的部分）
// 因此 x^12 = x^(2^3 + 2^2) 
// 转成乘法就是  x^12 = x^(2^3）*x^(2^2) = x^8*x^4
// 分析出这样的结果又有什么意义呢？请看下面：
// 1        1        0       0    <-算法从这里开始
// x^8      x^4      x^2     x^1 
// x^4*x^4  x^2*x^2  x*x
// 我们完全可以按照0011的顺序循环，从x^2开始逐步到x^8， 而不需要递归求x^8的结果

function quickPow(x, n) {
    var res = 1;
    while (n) {
        if (n & 1) res *= x; //（二进制操作）比如对于1100，实际上我们只需要计算1的部分 这种写法也可以用于判断奇偶数，奇数：1，偶数：0
        x *= x; //有了上面的图表，这一步很好理解了，从x^2开始，充分利用现有计算结果
        console.log('---myPow n=', n, 'x=', x, 'res=', res);
        n >>= 1; //（二进制操作）右位移去掉末尾1位,也可以看成是除以2取整数， 对于1100 循环下来变成 110 11 1 0000，达到按照0、0、1、1顺序计算的目的
    }
    return res;
}
// 整段代码下来，是完全看不到公式x^(2^(m-1)*i)的痕迹的,所以重点不是公式，而是从分析的结果寻找规律，
// 如果在代码里使用了这个公式，就达不到充分利用现有计算结果的目的
// 短短的几行代码，浓缩了整整一个篇幅的思想
// 充分体会二进制的魅力吧 
console.log('quickPow(a, n) 2^4', quickPow(2, 12));



// 与运算：先写成2进制，然后同位比较，都为1时此位为1，否则为0
// 12=1100
// console.log('num & 1;', 12 & 1); //0
// 13=1101
// console.log('num & 1;', 13 & 1); //1
// 12=1100 8=1000 
// console.log('num & n', 12 & 8); //1000 = 8
// 8=1000 7=0111 
// console.log('num & n', 8 & 7); //0000 = 0


// 右移赋值 >>= 移位操作 >>>
// var testNum = 8;  //8的二进制位1000。
// testNum >>> 1;  //向右移1位，为0100 就是4
// // console.log('num >>= 1;', 12>>>=1);// Uncaught ReferenceError: Invalid left-hand side in assignment
// var testNum = 12;
// console.log('num >>= 1;', testNum >>= 1); //6 1100 => 0110


// 幂函数
// console.log('2^3', Math.pow(2, 3));
// console.log('2^4', Math.pow(2, 4));